# 项目

## 1 编程平台

### 1 项目介绍

**背景：**

1. 编程平台一个少儿编程项目，可以用打积木的方式做游戏
1. 使用了一个开源的编辑器 scratch，是麻省理工开发的。目前市面上的少儿编程类的产品大多用的是 scratch
1. 我们做的就是接入自己的账号系统，搭建一个社区和做线上教程
1. 目前用于万科远航班学校的编程课教学，并且对外开放了
1. 项目包含各个端，PC 端、桌面端、移动端、移动客户端、管理端

### 2 项目优化

**问题背景：**

1. scratch 是一个开源的项目，但是它不是一个库拿过来就能用，而是一个完整的应用，耦合了一些其他的业务逻辑
1. 项目因为时间紧急，scratch 项目复杂，没有足够的时间调研
1. 花了两天的时间，大概看了一下这个项目，就决定直接在这个项目上做二次开发

**造成的问题：**

1. scratch 代码很多，打包比较慢
1. 业务逻辑越来越多项目就越臃肿，难以管理
1. 后期要开发桌面端，桌面端会有些差异化，比如静态资源，路由
1. 还有移动端，需要依赖作品运行器

**解决方案：**

1. 后面切到 umi 重构了，umi 整合了 dva，开发效率较高
1. 把 scratch 作为一个组件库单独管理，提供编辑器和运行器组件。它的打包方式也得改，我把它重写了，改成库的打包方式，静态资源打包到一起
1. 把这几个项目公用的工具类的方法，公共组件提出来作为一个公共的库

**难点：**

1. 这里的难点就是 scratch 本身是很复杂的项目，这里考验的就是对复杂项目源码的阅读
1. 但是这个过程是渐进式的。不是一次性就能搞完

**结果：**

1. 项目打包时间快了 50%
1. 项目整体变得很简介
1. 通常有些项目是越做越难维护，但是这个项目是越来越好维护

### 3 性能优化

**常规的优化：**

1. 各个页面按需加载
1. 压缩图片
1. 一些不怎么更新的库，合并在一起
1. 预加载 scratch 编辑器
1. 缓存作品使用 indexDB 缓存作品，防丢失，快速二次加载

### 4 缓存作品

**问题：**

1. scratch 作品添加素材后会特别大，达到十几兆
1. 导致保存需要比较久的时间
1. 意外关闭浏览器会丢失作品

**解决方案：**

1. 最开始考虑用 localStorage 保存，但是 localStorage 有限制大小，大概 5M 左右，浏览器不一样
1. 后来了解到可以使用 indexDB
1. indexDB 原生的用法没有过多研究，使用了一个库 `idb-keyval`，通过 KV 的形式存储

1. 在操作作品的时候，通过一个防抖函数，两秒未操作就会保存到 indexDB 中
1. 保存的时候可以放在后台保存，不需要一直等待
1. 而且会打一个标记，如果上次没有保存成功，下次打开页面的时候会自动保存(考虑冲突)
1. 然后打开作品的时候，判断打开的作品是否是上次操作过的，再根据更新时间判断是否需要从服务端加载
1. 如果不需要就直接读缓存的作品

### 5 作平同步

**背景：**

- 桌面端需要支持离线使用和弱网环境，未登录时作平存在本地，登录后同步到服务器
- 同步作品放在主进程，考虑到后期会有多窗口。放主进程一是更稳定，二是减轻渲染进程压力

**流程：**

- 不管是否登录，作品都是存在本地
- 在登录状态下保存，作品保存在本地后会马上同步到服务器
- 回到作品列表的时候会检查所有作品的同步状态
  1. 根据用户查询本地和服务器的所有作品
  2. 将服务端的作品列表以 serverId 存在一个 map 里面，作品有 serverId 和 localId
  3. 遍历本地的作品列表
  4. 如果作品没有 serverId 说明是新创建的作品，就需要在服务端也创建
  5. 如果有 serverId 但是在服务器列表里面的作品查不到，说明这个作品被删了，本地也删除
  6. 下面对比 localUpdateTime 和 serverUpdateTime，本地更新时间用来判断作品内容是否改变，服务端更新时间用来判断作品其他信息是否改变
  7. 如果本地更新时间更大，就更新到服务器
  8. 否则就更新作品信息到本地，不更新作品内容
  9. 这时需要把服务端作品列表中对比过的作品删除
  10. 遍历完本地作品后，再遍历剩余的服务端的作品
  11. 这时剩余的作品就是本地没有的，需要在本地创建
- 本地作品存有同步的状态，会在列表显示

**主进程渲染进程通信：**

- ipc 通信，通过消息的方式，相对于是发布订阅模式

做了封装

```js
// 主进程
ipcMain.on('getProjectLlist', () => {
  mainWindow.webContents.send('getProjectLlist-reply', { code: 0, data: {} });
});

// 渲染进程
// 维护一个 eventList，防止重复监听
function post(event, data) {
  return new Promise((resolve, reject) => {
    const reply = `${event}-reply`;

    if (eventList[reply]) {
      ipcRenderer.removeListener(reply, eventList[reply]);
      eventList[reply]('cancel');
    }

    eventList[reply] = function(e, res) {
      // do something
    };

    ipcRenderer.on(reply, eventList[reply]);
    ipcRenderer.send(event, data);
  });
}
```

```js
// lowdb
// lowdb 数据保存在一个 json 文件里面
// 使用 lodash 的调用方式
db.get('project')
  .filter(item => {
    return item.userId === data.userId || (!item.userId && !item.serverId);
  })
  .sortBy(
    item => {
      if (item.disable === undefined) item.disable = 0;
      return -item.disable;
    },
    item => {
      return -item.localUpdateTime;
    }
  )
  .value();
```

### 6 扫码授权登录

**背景：**

- 少儿编程客户端 App 是面向 3-6 岁儿童的，目前会用于幼儿园上编程课
- 但是幼儿园的小朋友无法完成登录的操作，需要老师协助，扫码授权登录就是用于这个场景的
- 如果是老师手动帮忙输账号的话就比较麻烦

**账号系统：**

账号系统是这个系统的一个亮点

- 有三种类型的账号，教师、学生、家长
- 教师账号可以关联班级，能查看整个班级学生的作品
- 家长账号可以关联学生账号，家长在自己手机登录后，可以看到学生在班级创作的作品
- 家长账号可以切换到学生账号

**解决方案：**

- 学生进入应用时会建立 websocket 连接，拿到一个连接 ID
- 这时用这个连接 ID 生成一个二维码
- 教师端登录后进入一个授权页面，能看到班级所有的学生
- 选择一个学生后点击扫码，就能拿到二维码上的 连接 ID
- 然后把连接 ID 和学生 ID 一起提交给后端
- 后端把登录信息通过 websocket 发送给学生端

**技术难点：**

- websocket 的连接状态
- 在应用退到后台、锁屏、切换网络、或者弱网的环境连接可能会断开
- 需要监听这几种情况，检查连接的状态

### 7 微信授权登录

**背景：**

- 微信授权登录就是使用微信绑定我们系统里面注册过的账号
- 然后通过跳转到微信的二维码页面扫码，扫码后重定向回来

**问题：**

- 微信授权登录有两种方式
- 一是直接跳转到微信的二维码页面，配一个回跳的地址，扫码后跳转回到这个地址，这样就跳转了两次
- 二是用 iframe，可以嵌到自己页面里面，但是扫码后回跳还是会刷新页面

**解决方案：**

- 准备两个单独的静态页面，一个使用 iframe 用来展示微信的二维码，一个空页面用来接收回跳传回来的数据
- 使用一个弹框用 iframe 嵌那个展示二维码的页面，相当于套了两层 iframe
- 扫码后跳转就只在 iframe 里面进行
- 然后通过监听 iframe 的 onload 事件，拿到传回的 code
- 如果是跨域的 iframe，可以使用 postMessage 接收数据

## 2 考试系统

### 1 项目介绍

考试系统可以进行线上和线下考试。线上线下考试都需要在教师端进行选择题目组卷

线上考试在教师端创建一场考试后学生就能在课程平台答题

线下考试组卷后需要生成答题卡，答完后拿去扫描，在教师端进行批改

### 2 批量录题模块

**背景：**

- 准备一场考试的时候需要去题库里面选题组卷
- 课后练习可以直接到题库里面按知识点找题
- 大的考试就需要老师自己出题，这就得自己把题录到题库里面去

**问题：**

- 通常老师出试卷是用 word 文档出好一整张试卷
- 最开只实现了单题录入，就是提供一个表单，填题干、选项、答案这些，效率很低
- 后面就调研可以用富文本实现批量录入

**实现效果：**

- 批量录题通过上传 word 文档或者通过富文本编辑器录入多道题目的完整信息
- 可以自动的识别出题型、题干、选项、答案、解析等内容，对于不规范的题目会展示错误提示

**流程：**

- 富文本拿到的是一个 DOM 节点列表，这个列表的每一行都是一个 p 标签
- 拆分题目 (拿到题目的题型，题目的节点列表)
  1. 遍历节点列表
  1. 如果是题型声明，或者空行说明是新的一题
  1. 否则往旧的题里面 push
- 分析题目 (拆分题干、选项、答案、难度、来源、题目解析)，完成后题目为各项目的节点列表
  1. 正则匹配项目标志，比如选项格式是 `A.`
  1. 如果没匹配到说明是上一个项目的内容
- 格式化题目的各个项目 (比如题干是一个字符串，选项是一个数组)
  1. 合并题干
  1. 按字母序号拆分选项
  1. 拆分答案
- 校验

### 3 图片批注组件

**背景：**

- 批改试卷的时候，通常需要对图片加一些批注
- 类似微信截图工具那样的功能
- 并没有类似的工具，需要自己实现

**解决方案：**

- 考虑过使用原生的写，但是对 canvas 不太熟，工作量会比较大
- 后来找到一个绘图库 `fabric`

**实现：**

- 用策略模式实现的
- 主类：负责调度画笔，创建 `fabric` 实例
- 画笔类：每个画笔单独创建一个类，在主类里面生成实例
- 历史记录：用两个栈保存，一个撤销一个重做，有新操作的时候情况重做栈。保存一个 json，载入 json 可以直接展示

```js
class Drawer {
  constructor(el, imgBase64) {
    // 历史记录
    this.history = new History(this.canvas);

    this.rect = new Rect(this.canvas, this.history);
    // ... 实例化画笔
  }

  // 画矩形
  drawRect() {
    this.clearPrevBrush();
    this.fnClearPrevBrush = this.rect.init();
  }

  // 画圆
  drawCircle() {}

  // 获取图片
  getImage = scale => {};
}
```

```js
class Rect {
  constructor(canvas, history) {
    this.canvas = canvas;
    this.history = history;
  }

  init = () => {
    return this.initEvent();
  };

  initEvent = () => {
    // 绑定 mouse 事件
    // this.canvas.on('mouse:down', this.onMouseDown);
    // this.canvas.on('mouse:move', this.onMouseMove);
    // this.canvas.on('mouse:up', this.onMouseUp);
  };

  onMouseDown = e => {
    // 初始化矩形的配置，创建一个实例
    // let curRect = new fabric.Rect({
  };

  onMouseMove = e => {
    // 画矩形
  };

  onMouseUp = () => {
    // 保存一条历史记录
  };
}
```
